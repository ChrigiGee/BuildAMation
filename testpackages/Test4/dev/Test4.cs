// Automatically generated by Opus v0.00

namespace Test4
{
    // Define module classes here
    class MyDynamicLib : C.DynamicLibrary
    {
        public MyDynamicLib(Opus.Core.Target target)
        {
            var includeDir = this.PackageLocation.SubDirectory("include");
            this.headerFiles.Include(includeDir, "dynamiclibrary.h");

#if OPUSPACKAGE_PUBLISHER_DEV
            // TODO: can this be automated?
            if (target.HasPlatform(Opus.Core.EPlatform.Posix))
            {
                this.publishKeys.Add(C.PosixSharedLibrarySymlinks.MajorVersionSymlink);
                this.publishKeys.Add(C.PosixSharedLibrarySymlinks.MinorVersionSymlink);
                this.publishKeys.Add(C.PosixSharedLibrarySymlinks.LinkerSymlink);
            }
#endif
        }

        class SourceFiles : C.ObjectFileCollection
        {
            public SourceFiles()
            {
                var sourceDir = this.PackageLocation.SubDirectory("source");
                this.Include(sourceDir, "dynamiclibrary.c");
                this.UpdateOptions += SetIncludePaths;
                this.UpdateOptions += SetRuntimeLibrary;
            }

            [C.ExportCompilerOptionsDelegate]
            private void SetIncludePaths(Opus.Core.IModule module, Opus.Core.Target target)
            {
                var compilerOptions = module.Options as C.ICCompilerOptions;
                compilerOptions.IncludePaths.Include(this.PackageLocation.SubDirectory("include"));
            }

            [C.ExportCompilerOptionsDelegate]
            private static void SetRuntimeLibrary(Opus.Core.IModule module, Opus.Core.Target target)
            {
                var vcCompilerOptions = module.Options as VisualCCommon.ICCompilerOptions;
                if (vcCompilerOptions != null)
                {
                    vcCompilerOptions.RuntimeLibrary = VisualCCommon.ERuntimeLibrary.MultiThreadedDebugDLL;
                }
            }
        }

        [Opus.Core.SourceFiles]
        SourceFiles sourceFiles = new SourceFiles();

        [C.HeaderFiles]
        Opus.Core.FileCollection headerFiles = new Opus.Core.FileCollection();

        [Opus.Core.DependentModules]
        Opus.Core.TypeArray dependents = new Opus.Core.TypeArray(typeof(MyStaticLib));

        [Opus.Core.DependentModules(Platform=Opus.Core.EPlatform.Windows, ToolsetTypes=new[]{typeof(VisualC.Toolset)})]
        Opus.Core.TypeArray winVCDependents = new Opus.Core.TypeArray(typeof(WindowsSDK.WindowsSDK));

        [C.RequiredLibraries(Platform = Opus.Core.EPlatform.Windows, ToolsetTypes = new[] { typeof(VisualC.Toolset) })]
        Opus.Core.StringArray libraries = new Opus.Core.StringArray("KERNEL32.lib");

#if OPUSPACKAGE_PUBLISHER_DEV
        [Publisher.PublishModuleDependency]
        Opus.Core.Array<Opus.Core.LocationKey> publishKeys = new Opus.Core.Array<Opus.Core.LocationKey>(
            C.DynamicLibrary.OutputFile);
#endif
    }

    class MyStaticLib : C.StaticLibrary
    {
        public MyStaticLib()
        {
            var sourceDir = this.PackageLocation.SubDirectory("source");
            this.sourceFile.Include(sourceDir, "staticlibrary.c");
            this.sourceFile.UpdateOptions += SetIncludePaths;

            var includeDir = this.PackageLocation.SubDirectory("include");
            this.headerFiles.Include(includeDir, "staticlibrary.h");
        }

        [Opus.Core.SourceFiles]
        C.ObjectFile sourceFile = new C.ObjectFile();

        [C.HeaderFiles]
        Opus.Core.FileCollection headerFiles = new Opus.Core.FileCollection();

        [C.ExportCompilerOptionsDelegate]
        private void SetIncludePaths(Opus.Core.IModule module, Opus.Core.Target target)
        {
            var compilerOptions = module.Options as C.ICCompilerOptions;
            compilerOptions.IncludePaths.Include(this.PackageLocation.SubDirectory("include"));
        }
    }
}
